# å½“å˜é‡æ¶ˆå¤±ä¹‹æ—¶

åœ¨ä¹‹å‰çš„æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬ä»‹ç»è¿‡ä¸€äº›å…³äºå‡½æ•°å¼ç¼–ç¨‹çš„å†…å®¹ï¼Œä¼—æ‰€å‘¨çŸ¥ï¼Œå‡½æ•°å¼çš„ä¸€å¤§ç‰¹ç‚¹æ˜¯ä¸å¯å˜ï¼Œè€Œç»“æ„åŒ–ç¼–ç¨‹ä¸­çš„å¾ªç¯ç»“æ„é€šå¸¸éœ€è¦å˜é‡é©±åŠ¨è¿­ä»£ï¼Œæ‰€ä»¥åœ¨å‡½æ•°å¼ç¼–ç¨‹ä¸­éœ€è¦ä½¿ç”¨é€’å½’å–ä»£é€šå¸¸æ„ä¹‰ä¸Šçš„å¾ªç¯ã€‚æ¥ä¸‹æ¥ï¼Œè®©æˆ‘ä»¬å°è¯•ä¸ä½¿ç”¨å˜é‡æ¥å®Œæˆå‡½æ•°å¼ç¼–ç¨‹ä¸­å¸¸ç”¨çš„ã€Œå¾ªç¯ã€å‡½æ•°ã€‚

<!--more-->

## ä¸å¯å˜çš„ä¼˜åŠ¿

ã€Œå˜é‡ä¸å¯å˜ã€è¿™ç§è‡ªæˆ‘é™åˆ¶è¡Œä¸ºèƒ½ç»™æˆ‘ä»¬å¸¦æ¥ä»€ä¹ˆï¼Ÿ

é¦–å…ˆï¼Œæœ€å¤§çš„æ”¶ç›Šæ˜¯çº¿ç¨‹å®‰å…¨æ€§ã€‚åœ¨ç°ä»£ç¼–ç¨‹ä¸­ï¼Œæˆ‘ä»¬å¸¸å¸¸éœ€è¦é€šè¿‡å¤šçº¿ç¨‹æ¥å¤„ç†é«˜å¹¶å‘ä»¥åŠå……åˆ†åˆ©ç”¨ CPU å¤šæ ¸å¿ƒçš„ä¼˜åŠ¿ã€‚ä¼ ç»Ÿè§£å†³æ–¹æ¡ˆé€šå¸¸ä½¿ç”¨å…±äº«å†…å­˜æ¥å®ç°çº¿ç¨‹é—´é€šä¿¡ï¼Œç„¶åä½¿ç”¨é”æ¥è¿›è¡Œçº¿ç¨‹åŒæ­¥ã€‚ç„¶è€Œï¼Œè¿™ç§æ–¹å¼å¹¶ä¸æ˜“äºä½¿ç”¨ï¼Œç”šè‡³å¯èƒ½å¯¼è‡´æ­»é”é—®é¢˜ã€‚æ­¤å¤–ï¼Œé¢‘ç¹ä½¿ç”¨é”ä¹Ÿä¼šå¯¹æ€§èƒ½é€ æˆä¸åˆ©å½±å“ã€‚ç„¶è€Œï¼Œå½“å˜é‡ä¸å¯å˜æ—¶ï¼Œé—®é¢˜æœ¬èº«ä¹Ÿéšä¹‹æ¶ˆå¤±ï¼šæ‰€æœ‰çš„ç«æ€ã€æ­»é”ã€åŒæ­¥é—®é¢˜éƒ½æºäºå¯å˜å˜é‡ï¼Œå¦‚æœå˜é‡ä¸å†è¢«æ›´æ–°ï¼Œå°±ä¸ä¼šå‡ºç°ç«æ€ä¸åŒæ­¥é—®é¢˜ï¼›æ²¡æœ‰ç”¨æ¥é™åˆ¶å¯å˜å˜é‡çš„é”ï¼Œä¹Ÿå°±ä¸ä¼šå‘ç”Ÿæ­»é”ã€‚

ä¾‹å¦‚ï¼Œå‡½æ•°å¼è¯­è¨€ Erlang/Elixir å°±ä½¿ç”¨äº† Actor æ¨¡å‹æ¥è§£å†³å¹¶å‘ç¼–ç¨‹çš„é—®é¢˜ï¼Œè¿™ç§æ¨¡å‹é€šè¿‡æ¶ˆæ¯ä¼ é€’è€Œä¸æ˜¯å…±äº«å†…å­˜æ¥è¿›è¡Œé€šä¿¡ï¼Œä»è€Œé¿å…äº†è®¸å¤šçº¿ç¨‹å®‰å…¨æ€§çš„é—®é¢˜ã€‚

æ­¤å¤–ï¼Œç”±äºä¸éœ€è¦è€ƒè™‘çŠ¶æ€çš„å˜åŒ–ï¼Œé˜…è¯»ã€ç¼–å†™å’Œè°ƒè¯•ä»£ç å˜å¾—æ›´ä¸ºç®€æ´ç›´è§‚ï¼›åŒæ—¶ï¼Œç¼–è¯‘å™¨å’Œè¿è¡Œæ—¶ç¯å¢ƒæ›´å®¹æ˜“å¯¹ä»£ç è¿›è¡Œä¼˜åŒ–ï¼Œä»¥æé«˜è¿è¡Œæ•ˆç‡ã€‚

è¿™å¹¶ä¸æ˜¯çº¸ä¸Šè°ˆå…µã€‚åœ¨æœ€åŸºæœ¬çš„ç¼–ç¨‹è¯­è¨€è¯­æ³•å±‚é¢ä¸Šï¼Œç°ä»£ç¼–ç¨‹è¯­è¨€éƒ½æ›´åå‘ `val`ã€`let`ã€`const` è€Œä¸æ˜¯ `const auto`ã€`final var`ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œé€šè¿‡ç®€åŒ–å¸¸é‡å£°æ˜æ–¹å¼ï¼Œä½¿äººä»¬åœ¨å¿ƒç†ä¸Šæ›´å®¹æ˜“æ¥å—å¸¸é‡ï¼Œå¾ˆæ˜æ˜¾ï¼Œæ²¡æœ‰äººæ„¿æ„é‡å¤ä¹¦å†™ `const T *const` è¿™ç§ç¹ççš„å¸¸é‡ç±»å‹ã€‚åŒç†ï¼Œ`mut foo: &mut T` è¿™ç§ç¹ççš„å˜é‡å£°æ˜æ–¹å¼ä¹Ÿä¼šé€¼è¿«äººä»¬é€‰æ‹©ä½¿ç”¨å¸¸é‡å°†å…¶ä»£æ›¿ã€‚è¯´åˆ°åº•ï¼Œè¿™æ˜¯ä¸€ç§é»˜è®¤æ€è·¯çš„è½¬å˜ï¼šä»ã€Œå¸¸é‡åªæ˜¯ä¸€ç§é™åˆ¶å˜é‡çš„ä¿®é¥°ã€åˆ°ã€Œçº¯å‡½æ•°å¼çš„ä¸–ç•Œé‡Œåªæœ‰å¸¸é‡ï¼Œä¸è¿‡æœ‰æ—¶å¯ä»¥ä¸é‚£ä¹ˆçº¯ã€ã€‚

å‘ä¸Šçœ‹å»ï¼Œä¾¿æ¥åˆ°äº†ä¸å¯å˜å¯¹è±¡ä¸æ•°æ®ç»“æ„ï¼Œæ‰€è°“ã€Œä¸å¯å˜ã€çš„æ„æ€æ˜¯åœ¨è¢«åˆ›å»ºåï¼Œå…¶ç»“æ„å†…éƒ¨å„å±æ€§æˆ–å­—æ®µéƒ½ä¸èƒ½é€šè¿‡ä»»ä½•æ–¹å¼è¿›è¡Œä¿®æ”¹ï¼Œä½†å¯ä»¥é€šè¿‡åˆ›å»ºæ–°çš„å¯¹è±¡æ¥å–ä»£æ—§å¯¹è±¡ï¼Œæ˜¾ç„¶ï¼Œè¿™äº›å¯¹è±¡å¤©ç„¶çº¿ç¨‹å®‰å…¨ï¼Œå¹¶ä¸”å…¶æ–¹æ³•çš†ä¸ºæ— å‰¯ä½œç”¨çš„çº¯å‡½æ•°ã€‚æ¯”è¾ƒå¸¸è§çš„ä¾‹å­æœ‰å­—ç¬¦ä¸²ã€æ—¶é—´å¤„ç†ç›¸å…³ç­‰ã€‚

```kotlin
import java.time.LocalDate

fun main() {
    val today = LocalDate.now();
    val oneYearLater = today.plusYears(1);
    println("today: $today, oneYearLater: $oneYearLater")
    println(oneYearLater.dayOfWeek)
    // today: 2024-04-19, oneYearLater: 2025-04-19
    // SATURDAY
}
```

ä¸è¯»ä½œ Kotlinï¼Œå†™ä½œ Java çš„ `LocalDate` å½¢æˆé²œæ˜å¯¹æ¯”çš„ä¾¿æ˜¯ä»…åœ¨ 10 å¤©å†…å°±ï¼ˆä¸å¾—å·²ï¼‰å¸å–äº† Java ä¸å°‘ç³Ÿç²•ï¼Œå¹¶ç›´åˆ° 29 å¹´åçš„ä»Šæ—¥ä»çº ç¼ ä¸æ¸…çš„ JavaScript çš„ `Date`ã€‚ï¼ˆ`java.util.Date`ï¼šå£é»‘ï¼Œäº»å°”å¥³å­ï¼ï¼‰[^1]

```typescript
const today = new Date()
today.setFullYear(today.getFullYear() + 1)
console.log(`oneYearLater: ${today.toDateString()}`)
console.log(today.getDay())
// oneYearLater: Sat Apr 19 2025
// 6
```

è™½ç„¶æ²¡æœ‰è‡ªå·±çš„æ—¶é—´å¤„ç†æ–¹æ¡ˆï¼Œä½†å¾—ç›Šäºå¯¹ Scala çš„å¤§é‡å€Ÿé‰´ï¼ŒKotlin æœ‰ç€ä¸€æ•´å¥—å¯å˜ä¸ä¸å¯å˜çš„é›†åˆç±»ï¼Œä»»å›é€‰æ‹©ã€‚

![Collection interfaces hierarchy](https://kotlinlang.org/docs/images/collections-diagram.png)

å†™åˆ°è¿™é‡Œï¼Œä¾¿å›å¿†èµ·ä¸€ä»¶è‡ªå·±äº²èº«ç»å†è¿‡çš„ã€Œå™©æ¢¦ã€ï¼šï¼ˆå¥½å§ï¼Œå…¶å®å°±æ˜¯ä¸ºäº†è¿™ç‚¹é¦…åŒ…äº†è¿™é”… ğŸ¥Ÿã€‚ï¼‰

```typescript
const regex = /foo/g
const s = 'play football'

console.log(regex.test(s))
console.log(regex.test(s))
```

è¿™æ®µä»£ç çš„ä½œç”¨æ˜¯åˆ©ç”¨æ­£åˆ™è¡¨è¾¾å¼æ£€æµ‹å­—ç¬¦ä¸²ä¸­æ˜¯å¦å«æœ‰ã€Œ`foo`ã€ï¼Œç¨‹åºè¿è¡Œç»“æœæ˜¾è€Œæ˜“è§ï¼Œ

```
true
true
```

**å—ï¼Ÿ**

```
true
false
```

> ã€Œæƒ³è±¡å¦ä¸€ç§ç»“æœï¼šç¬¬ä¸€æ¬¡ï¼Œç™½çƒå°†é»‘çƒæ’å…¥æ´å†…ï¼›ç¬¬äºŒæ¬¡ï¼Œé»‘çƒèµ°åäº†ï¼›ç¬¬ä¸‰æ¬¡ï¼Œé»‘çƒé£ä¸Šäº†å¤©èŠ±æ¿ï¼›ç¬¬å››æ¬¡ï¼Œé»‘çƒåƒä¸€åªå—æƒŠçš„éº»é›€åœ¨æˆ¿é—´é‡Œä¹±é£ï¼Œæœ€åé’»è¿›äº†æ‚¨çš„è¡£è¢‹ï¼›ç¬¬äº”æ¬¡ï¼Œé»‘çƒä»¥æ¥è¿‘å…‰é€Ÿçš„é€Ÿåº¦é£å‡ºï¼ŒæŠŠå°çƒæ¡Œæ²¿æ’å‡ºä¸€ä¸ªç¼ºå£ï¼Œå‡»ç©¿äº†å¢™å£ï¼Œç„¶åé£å‡ºåœ°çƒï¼Œé£å‡ºå¤ªé˜³ç³»ï¼Œå°±åƒé˜¿è¥¿è«å¤«æå†™çš„é‚£æ ·ã€‚è¿™æ—¶æ‚¨æ€ä¹ˆæƒ³ï¼Ÿ
>
> â€¦â€¦
>
> ã€Œè¿™å°±æ„å‘³ç€å®‡å®™æ™®é€‚çš„ç‰©ç†è§„å¾‹ä¸å­˜åœ¨ï¼Œé‚£ç‰©ç†å­¦â€¦â€¦ä¹Ÿä¸å­˜åœ¨äº†ã€‚ã€
>
> â¸ºã€Šä¸‰ä½“ã€‹

å®ä¸ç›¸ç’ï¼Œè¿™æ®µæ ·ä¾‹æ­£æ˜¯æºäºåšå®¢å¤„ç†è„šæ³¨çš„ä»£ç ï¼Œåœ¨é‚£ä¸ªæœˆé»‘é£é«˜çš„å¤œæ™šï¼Œå½“é‡åˆ°è¿™ä¸ªéš¾ä»¥ç½®ä¿¡çš„ç„å­¦å¹½çµäº‹ä»¶æ—¶ï¼Œæˆ‘çš„å¿ƒæƒ…å°±æ˜¯ã€Œè®¡ç®—æœºç§‘å­¦ä¸å­˜åœ¨äº†ã€ã€‚

è¨€å½’æ­£ä¼ ï¼ŒçœŸç›¸å…¶å®å¾ˆç®€å•ï¼Œå½“ä½ çŸ¥é“æœ‰ `lastIndex` è¿™ç§ä¸‡æ¶ä¹‹æºå­˜åœ¨æ—¶ï¼š

```typescript
const regex = /foo/g
const s = 'play football'

console.log(regex.test(s), regex.lastIndex)
console.log(regex.test(s), regex.lastIndex)
// true 8
// false 0
```

ç®€å•æ¥è¯´ï¼Œ`const regex = /foo/g` å¹¶ä¸åªæ˜¯å•çº¯åœ°å®šä¹‰ä¸€ä¸ªæ­£åˆ™è¡¨è¾¾å¼å­—é¢é‡ï¼Œè€Œæ˜¯å®ä¾‹åŒ–äº†ä¸€ä¸ª `RegExp` å¯¹è±¡ï¼Œè€Œå…¶ä¸­çš„ lastIndex å±æ€§ä¼šéšç€æ–¹æ³•è°ƒç”¨è€Œéšä¹‹å˜åŒ–ã€‚è™½ç„¶ä»é¢å‘å¯¹è±¡çš„è§’åº¦æ¥çœ‹å¯èƒ½æ²¡æœ‰ä»€ä¹ˆé—®é¢˜ï¼Œä½†ä¸çº¯ç²¹å°±æ˜¯åæ–‡æ˜ï¼ï¼ˆ**ä¸‹æ¬¡ä¸€å®š**ä»”ç»†é˜…è¯»æ–‡æ¡£ã€‚ï¼‰

è¿˜æ˜¯æ¥çœ‹çœ‹ Kotlin å§ï¼š

```kotlin
fun main() {
    val regex = Regex("/foo/g")
    val s = "play football"
    println(regex.containsMatchIn(s))
    println(regex.containsMatchIn(s))
    // false
    // false
}
```

ä½ çœ‹ï¼Œè¿™ç§ä¸å¯å˜å¯¹è±¡å°±ç”¨èµ·æ¥å¾ˆæ”¾å¿ƒã€‚

é¡ºå¸¦ä¸€æï¼Œè™½ç„¶åˆšåˆšåæ§½äº† JS çš„ `Date`ï¼Œä½†æ–°çš„æ—¥æœŸå¤„ç†æ–¹æ¡ˆ [Temporal](https://github.com/tc39/proposal-temporal) æŒ‡æ—¥å¯å¾…ã€‚ç›®å‰è¯¥ææ¡ˆé©¬ä¸Šè¿›å…¥ Stage 4ï¼Œä¹‹å‰æˆ‘åœ¨é¡¹ç›® SubMGR ä¸­ä¹Ÿé€šè¿‡å¼•å…¥ polyfill æå‰è¿›è¡Œäº†ä½“éªŒï¼Œéå¸¸å¥½ç”¨ã€‚

ç»§ç»­å‘ä¸Šï¼Œå‡½æ•°å¼æ€æƒ³å¯¹æ¡†æ¶é¢†åŸŸä¹Ÿæœ‰ç€æ·±åˆ»å½±å“ã€‚å¦‚å‰ç«¯çš„æ ‡å¿—æ€§æ¡†æ¶ Reactï¼š

```typescript
const [names, setNames] = useState(['BioniCosmos'])
// Wrong!
// names.push('Daniel')
// Correct!
setNames([...names, 'Daniel'])
```

ä»¥åŠå¤§æ•°æ®é¢†åŸŸçš„ Sparkã€Hadoopã€‚ï¼ˆè¿™æ–¹é¢å°±ä¸å¤ªäº†è§£å•¦ã€‚ï¼‰

çŸ¥é“äº†å„ç§ä¼˜ç‚¹ï¼Œæ¥ä¸‹æ¥å°±è®©æˆ‘ä»¬å…ˆæ¥çœ‹çœ‹é€’å½’çš„å¨åŠ›ã€‚

## é€’å½’å–ä»£å¾ªç¯

å¯¹äºåˆå­¦è€…æ¥è¯´ï¼Œé€’å½’å¯èƒ½æ˜¯ä¸€ç§è¾ƒä¸ºæŠ½è±¡çš„æ€æƒ³ï¼Œåªå¯æ„ä¼šï¼Œä¸å¯è¨€ä¼ ï¼Œç›¸æ¯”ä¹‹ä¸‹ï¼Œå¾ªç¯æ›´ä¸ºç®€å•ç›´æ¥ï¼Œç‰¹åˆ«æ˜¯å¯¹äºåƒã€Œè¾“å‡º 0â€”9 åä¸ªæ•°ã€è¿™æ ·çš„ä»»åŠ¡ã€‚ç„¶è€Œï¼Œä¸€æ—¦ç†Ÿæ‚‰äº†é€’å½’ï¼Œå°±ä¼šå‘ç°å®ƒçš„ç®€æ´å’Œå¼ºå¤§ä¹‹å¤„ã€‚

åºŸè¯å°‘è¯´ï¼Œæˆ‘ä»¬ç›´æ¥æ¥çœ‹ç¬¬ä¸€ä¸ªä¾‹å­ï¼šæ–æ³¢é‚£å¥‘æ•°åˆ—ã€‚

```java
public class Fibonacci {
    public static int fibonacci(int n) {
        if (n <= 1) {
            return n;
        }
        var a = 0;
        var b = 1;
        var c = 0;
        for (var i = 2; i <= n; i++) {
            c = a + b;
            a = b;
            b = c;
        }
        return c;
    }
}
```

```haskell
fib n
  | n <= 1 = n
  | otherwise = fib (n - 1) + fib (n - 2)
```

æ„Ÿè§‰å¦‚ä½•ï¼Ÿæ²¡è¿‡ç˜¾ï¼Ÿé‚£å†æŠŠç¬¬äºŒä¸ªä¾‹å­â¸ºå¿«é€Ÿæ’åºç«¯ä¸Šæ¥å§ã€‚

```java
public class QuickSort {
    public static void quickSort(int[] arr) {
        quickSort(arr, 0, arr.length - 1);
    }

    private static void quickSort(int[] arr, int left, int right) {
        if (left >= right) {
            return;
        }
        var pivot = partition(arr, left, right);
        quickSort(arr, left, pivot - 1);
        quickSort(arr, pivot + 1, right);
    }

    private static int partition(int[] arr, int left, int right) {
        var pivot = arr[right];
        var i = left - 1;
        for (var j = left; j < right; j++) {
            if (arr[j] <= pivot) {
                i += 1;
                swap(arr, i, j);
            }
        }
        i += 1;
        swap(arr, i, right);
        return i;
    }

    private static void swap(int[] arr, int i, int j) {
        var temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

```haskell
quickSort [] = []
quickSort (x : xs) =
  quickSort (filter (<= x) xs)
    ++ [x]
    ++ quickSort (filter (> x) xs)
```

æˆ‘æ‰¿è®¤è¿™åœºæ¯”èµ›ç§°ä¸ä¸Šå…¬å¹³ï¼Œä¾‹å­ä¹Ÿæœ‰äº›æ–‡ä¸å¯¹é¢˜ï¼Œä½†èŠ‚ç›®æ•ˆæœåº”è¯¥æ˜¯è¾¾åˆ°äº†ã€‚ä¸ç®¡æ€ä¹ˆè¯´ï¼Œé€’å½’ä¸å‡½æ•°å¼å®åœ¨æ˜¯ä¼˜é›…ã€‚

æ—¢ç„¶æœ‰äº†ã€Œé€’å½’ã€è¿™æŠŠåˆ©å™¨ï¼Œæˆ‘ä»¬å°±å¯ä»¥æ­£å¼å¼€å§‹å®ç°é‚£äº›è€³ç†Ÿèƒ½è¯¦çš„å‡½æ•°äº†ã€‚

## å®ç°å¸¸ç”¨å‡½æ•°

æ¥ä¸‹æ¥ä»‹ç»çš„æ‰€æœ‰å‡½æ•°å°†åˆ†åˆ«ä½¿ç”¨ TypeScriptã€Kotlinã€Haskellã€Elixirã€Racket äº”é—¨è¯­è¨€ç¼–å†™ã€‚

### `reduce`

ä¼ è¯´ä¸­ï¼ŒæŒæ¡äº† `reduce` å°±æŒæ¡äº†ä¸€åˆ‡ã€‚

`reduce` å‡½æ•°æ˜¯å‡½æ•°å¼ç¼–ç¨‹ä¸­çš„ä¸€ä¸ªé‡è¦é«˜é˜¶å‡½æ•°ï¼Œå®ƒçš„ä½œç”¨æ˜¯å°†ä¸€ä¸ªé›†åˆä¸­çš„æ‰€æœ‰å…ƒç´ æŒ‰ç…§æŒ‡å®šçš„è§„åˆ™è¿›è¡Œå½’çº¦ï¼Œæœ€ç»ˆå¾—åˆ°ä¸€ä¸ªå•ä¸€çš„ç»“æœã€‚ä½¿ç”¨å¾ªç¯å®ç° `reduce` çš„ä»£ç å¦‚ä¸‹ï¼š

```typescript
const reduce = <T, U>(f: (acc: U, x: T) => U, init: U, xs: T[]): U => {
  let acc = init
  for (const x of xs) {
    acc = f(acc, x)
  }
  return acc
}
```

é‚£ä¹ˆä½¿ç”¨é€’å½’åº”è¯¥å¦‚ä½•å®ç°å‘¢ï¼Ÿ

1. å°†ç¬¬ä¸€ä¸ªå…ƒç´ ä¼ å…¥ `f` ä¸­ã€‚
2. å°† `f` çš„è¿”å›å€¼å’Œå‰©ä½™å…ƒç´ ä¼ å…¥ `reduce` ä¸­ç»§ç»­è¿ç®—ã€‚
3. é‡å¤ä¸Šè¿°è¿‡ç¨‹ï¼Œç›´åˆ°é›†åˆä¸­åªå‰©ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œæ­¤æ—¶ç»ˆæ­¢é€’å½’å¹¶ç›´æ¥è¿”å› `f` è°ƒç”¨åçš„è¿”å›å€¼å³å¯ã€‚

å°†æ¯ä¸€æ­¥å±•å¼€åçš„ä»£ç è¿‡ç¨‹å¦‚ä¸‹ï¼š

```typescript
const f = (acc, x) => acc + x
reduce(f, 0, [1, 2, 3])
// (0, 1) => 0 + 1
reduce(f, 1, [2, 3])
// (1, 2) => 1 + 2
reduce(f, 3, [3])
// (3, 3) => 3 + 3
reduce(f, 6, [])
// return 6
```

#### TypeScript

```typescript
const reduce = <T, U>(f: (acc: U, x: T) => U, init: U, list: T[]): U => {
  if (list.length === 0) {
    return init
  }
  const [x, ...xs] = list
  return reduce(f, f(init, x), xs)
}
```

#### Kotlin

```kotlin
tailrec fun <T, U> List<T>.reduce(init: U, f: (U, T) -> U): U {
    if (this.isEmpty()) {
        return init
    }
    val x = this.first()
    val xs = this.drop(1)
    return xs.reduce(f(init, x), f)
}
```

#### Haskell

```haskell
reduce f init [] = init
reduce f init (x : xs) = reduce f (f init x) xs
```

#### Elixir

```elixir
def reduce([], init, _), do: init
def reduce([x | xs], init, f), do: reduce(xs, f.(x, init), f)
```

#### Racket

```clojure
(define/match (reduce f init _xs)
  [(_ _ (list)) init]
  [(_ _ (cons x xs)) (reduce f (f init x) xs)])
```

### `map`

`map` æ˜ å°„å‡½æ•°æ˜¯ä¸€ä¸ªæˆ‘å¾ˆå–œæ¬¢çš„å‡½æ•°ï¼Œå› ä¸ºå®ƒèƒ½ç›´è§‚åœ°ä½“ç°å‡ºæ•°æ®åœ¨å‡½æ•°é—´æµè½¬å¤„ç†çš„è¿‡ç¨‹ã€‚`map` å¸¸ç”¨äºé›†åˆç»“æ„ï¼Œä¹Ÿå¯ç”¨äº Monadï¼Œå…¶ä½œç”¨ä¸ºå°†ç±»å‹ T è½¬æ¢ï¼ˆæ˜ å°„ï¼‰åˆ°ç±»å‹ Uã€‚

ç›¸æ¯”äº `reduce`ï¼Œ`map` ç”¨æ³•å•ä¸€ï¼Œå®ç°ä¸Šä¹Ÿæ›´ä¸ºç®€å•ã€‚å¾ªç¯å®ç°å¦‚ä¸‹ï¼š

```typescript
const map = <T, U>(f: (x: T) => U, xs: T[]): U[] => {
  const mapped = Array.of<U>()
  for (const x of xs) {
    mapped.push(f(x))
  }
  return mapped
}
```

è‹¥ä¸ä½¿ç”¨å¾ªç¯ï¼Œæ—¢å¯ä»¥ç”¨ä¸‡èƒ½çš„ `reduce` ä¹Ÿå¯ä»¥ç›´æ¥ç”¨é€’å½’å®ç°ï¼Œå®ç°æ€è·¯ä¸å¾ªç¯å¹¶æ— åŒºåˆ«ï¼Œåªä¸è¿‡å°† `push` æ›¿æ¢ä¸ºæ‹¼æ¥ã€‚

#### TypeScript

```typescript
const map = <T, U>(f: (x: T) => U, xs: T[]): U[] =>
  reduce((acc, x) => [...acc, f(x)], Array.of(), xs)
```

```typescript
const map = <T, U>(f: (x: T) => U, list: T[]): U[] => {
  if (list.length === 0) {
    return []
  }
  const [x, ...xs] = list
  return [f(x), ...map(f, xs)]
}
```

#### Kotlin

```kotlin
fun <T, U> List<T>.map(f: (T) -> U): List<U> =
    this.reduce(listOf()) { acc, x -> acc + f(x) }
```

```kotlin
fun <T, U> List<T>.map(f: (T) -> U): List<U> {
    if (this.isEmpty()) {
        return listOf()
    }
    val x = this.first()
    val xs = this.drop(1)
    return listOf(f(x)) + xs.map(f)
}
```

#### Haskell

```haskell
map f = reduce (\acc x -> acc ++ [f x]) []
```

```haskell
map f [] = []
map f (x : xs) = f x : map f xs
```

#### Elixir

```elixir
def map(xs, f), do: reduce(xs, [], fn x, acc -> acc ++ [f.(x)] end)
```

```elixir
def map([], _), do: []
def map([x | xs], f), do: [f.(x) | map(xs, f)]
```

#### Racket

```clojure
(define (map f xs)
  (reduce (lambda (acc x) (append acc (list (f x)))) null xs))
```

```clojure
(define/match (map f _xs)
  [(_ (list)) null]
  [(_ (cons x xs)) (cons (f x) (map f xs))])
```

### `filter`

æ¥ä¸‹æ¥æ˜¯ `filter`ï¼Œå®ƒèƒ½å¤Ÿæ ¹æ®æŒ‡å®šçš„æ¡ä»¶ç­›é€‰å‡ºç¬¦åˆæ¡ä»¶çš„å…ƒç´ ã€‚

```typescript
const filter = <T>(f: (x: T) => boolean, xs: T[]): T[] => {
  const filtered = Array.of<T>()
  for (const x of xs) {
    if (f(x)) {
      filtered.push(x)
    }
  }
  return filtered
}
```

#### TypeScript

```typescript
const filter = <T>(f: (x: T) => boolean, xs: T[]): T[] =>
  reduce((acc, x) => (f(x) ? [...acc, x] : acc), Array.of(), xs)
```

```typescript
const filter = <T>(f: (x: T) => boolean, list: T[]): T[] => {
  if (list.length === 0) {
    return []
  }
  const [x, ...xs] = list
  return f(x) ? [x, ...filter(f, xs)] : filter(f, xs)
}
```

#### Kotlin

```kotlin
fun <T> List<T>.filter(f: (T) -> Boolean): List<T> =
    this.reduce(listOf()) { acc, x -> if (f(x)) acc + x else acc }
```

```kotlin
fun <T> List<T>.filter(f: (T) -> Boolean): List<T> {
    if (this.isEmpty()) {
        return listOf()
    }
    val x = this.first()
    val xs = this.drop(1)
    return if (f(x)) listOf(x) + xs.filter(f) else xs.filter(f)
}
```

#### Haskell

```haskell
filter f = reduce (\acc x -> if f x then acc ++ [x] else acc) []
```

```haskell
filter f [] = []
filter f (x : xs)
  | f x = x : filter f xs
  | otherwise = filter f xs
```

#### Elixir

```elixir
def filter(xs, f),
  do:
    reduce(xs, [], fn x, acc ->
      cond do
        f.(x) -> acc ++ [x]
        true -> acc
      end
    end)
```

```elixir
def filter([], _), do: []
def filter([x | xs], f) do
  cond do
    f.(x) -> [x | filter(xs, f)]
    true -> filter(xs, f)
  end
end
```

#### Racket

```clojure
(define (filter f xs)
  (reduce (lambda (acc x) (if (f x) (append acc (list x)) acc)) null xs))
```

```clojure
(define/match (filter f _xs)
  [(_ (list)) null]
  [(_ (cons x xs)) (if (f x) (cons x (filter f xs)) (filter f xs))])
```

### `reverse`

å…³äºç¿»è½¬å‡½æ•°çš„ä½œç”¨æƒ³å¿…æ— éœ€è§£é‡Šã€‚ä½¿ç”¨å¾ªç¯å®ç°ç¿»è½¬å‡½æ•°çš„ç»å…¸æ€è·¯æ˜¯å°±åœ°äº¤æ¢ï¼Œè¿™ä¸é€’å½’å®ç°å·®åˆ«å¾ˆå¤§ï¼Œæ‰€ä»¥è€ƒè™‘å¦ä¸€ç§æ€è·¯ï¼šä»åå‘å‰éå†ï¼Œå°†å…ƒç´ æ¨å…¥æ–°çš„é›†åˆä¸­ï¼š

```typescript
const reverse = <T>(xs: T[]): T[] => {
  const reversed = Array.of<T>()
  for (let i = xs.length - 1; i >= 0; i--) {
    reversed.push(xs[i])
  }
  return reversed
}
```

é€’å½’å®ç°æ€è·¯ç±»ä¼¼ï¼š

1. å°†é›†åˆåˆ†ä¸ºé¦–å…ƒç´  `x` å’Œå…¶ä½™å…ƒç´ é›†åˆ `xs`ã€‚
2. ç¿»è½¬ `xs`ï¼š`reverse xs`ï¼ˆå¼€å§‹é€’å½’ï¼‰ã€‚
3. å°† `x` æ‹¼æ¥åˆ°ç¿»è½¬åçš„è¿”å›å€¼æœ«å°¾ã€‚

#### TypeScript

```typescript
const reverse = <T>(xs: T[]): T[] =>
  reduce((acc, x) => [x, ...acc], Array.of(), xs)
```

```typescript
const reverse = <T>(list: T[]): T[] => {
  if (list.length === 0) {
    return []
  }
  const [x, ...xs] = list
  return [...reverse(xs), x]
}
```

#### Kotlin

```kotlin
fun <T> List<T>.reverse(): List<T> =
    this.reduce(listOf()) { acc, x -> listOf(x) + acc }
```

```kotlin
fun <T> List<T>.reverse(): List<T> {
    if (this.isEmpty()) {
        return listOf()
    }
    val x = this.first()
    val xs = this.drop(1)
    return xs.reverse() + listOf(x)
}
```

#### Haskell

```haskell
reverse = reduce (flip (:)) []
```

ä¸æ„§æ˜¯ Haskellï¼Œè½»æ˜“åšåˆ°äº†å…¶ä»–è¯­è¨€åšä¸åˆ°çš„äº‹å‘¢ã€‚è®©æˆ‘ä»¬æŠŠä»£ç å±•å¼€ä»¥è¯´æ˜å…¶å«ä¹‰ã€‚

1. æœ€åˆå½¢æ€ï¼š

   ```haskell
   reverse xs = reduce (\acc x -> x : acc) [] xs
   ```

2. ç”±äº Partial Applicationï¼Œå¯æ¶ˆé™¤å‚æ•° `xs`ï¼š

   ```haskell
   reverse = reduce (\acc x -> x : acc) []
   ```

3. è§‚å¯Ÿ lambda è¡¨è¾¾å¼ï¼Œæˆ‘ä»¬å°† `:` ä¸­ç¼€è¿ç®—ç¬¦è½¬æ¢ä¸ºå‰ç¼€è°ƒç”¨å½¢å¼ï¼š

   ```haskell
   reverse = reduce (\acc x -> (:) x acc) []
   ```

4. å¯ä»¥å‘ç°ï¼Œlambda è¡¨è¾¾å¼çš„å‚æ•°é¡ºåºä¸ `:` çš„ä¼ å…¥é¡ºåºæ­£å¥½ç›¸åï¼Œé‚å¯ä»¥ä½¿ç”¨ `flip` å‡½æ•°äº¤æ¢å‚æ•°é¡ºåºå¹¶ç›´æ¥ä¼ å…¥å‡½æ•°ï¼ˆè¿ç®—ç¬¦ï¼‰ï¼š

   ```haskell
   reverse = reduce (flip (:)) []
   ```

ç›´æ¥å®ç°çš„ä»£ç å°±æ¯”è¾ƒæ­£å¸¸äº†ï¼š

```haskell
reverse [] = []
reverse (x : xs) = reverse xs ++ [x]
```

#### Elixir

```elixir
def reverse(xs), do: reduce(xs, [], fn x, acc -> [x | acc] end)
```

```elixir
def reverse([]), do: []
def reverse([x | xs]), do: reverse(xs) ++ [x]
```

#### Racket

```clojure
(define (reverse xs)
  (reduce (lambda (acc x) (cons x acc)) null xs))
```

```clojure
(define/match (reverse _xs)
  [((list)) null]
  [((cons x xs)) (append (reverse xs) (list x))])
```

### æœ‰å…³ `reduce` çš„è¡¥å……

`reduce` å¾ˆå¥‡ç‰¹ï¼Œè¯¸å¦‚ `map`ã€`filter` éƒ½æœ‰è¾ƒä¸ºæ˜ç¡®çš„ç”¨é€”ï¼Œä½† `reduce` ä¼¼ä¹ä»€ä¹ˆéƒ½èƒ½åšã€‚

å®é™…ä¸Š `reduce` å’Œå¾ªç¯æä¸ºç›¸ä¼¼ï¼Œåªä¸è¿‡æ¢äº†ä¸€ç§å½¢å¼ï¼Œåˆå°†å¯å˜æ“ä½œè½¬æ¢ä¸ºä¸å¯å˜æ“ä½œï¼ˆå¦‚å¯¹äºåˆ—è¡¨ï¼Œ`push` å˜ä¸ºæ‹¼æ¥ï¼‰ã€‚

## ä»€ä¹ˆï¼Ÿé€’å½’æ˜¯å‡çš„ï¼Ÿ

é€’å½’é€šå¸¸æ¯”å¾ªç¯æ›´ç®€å•ã€æ›´æ˜“ç†è§£ï¼Œè¿™æ˜¯ä¸ºä»€ä¹ˆå‘¢ï¼Ÿ

1. è‡ªç„¶è¡¨è¾¾ï¼šé€’å½’æ›´è‡ªç„¶åœ°è¡¨è¾¾äº†é—®é¢˜çš„é€’å½’ç»“æ„ï¼Œç‰¹åˆ«æ˜¯å¯¹äºé€’å½’å®šä¹‰çš„é—®é¢˜ï¼ˆå¦‚æ ‘ã€å›¾ç­‰ï¼‰ï¼Œä½¿ç”¨é€’å½’æ›´ç¬¦åˆé—®é¢˜çš„æœ¬è´¨ã€‚
2. ç®€æ´æ€§ï¼šé€’å½’èƒ½å¤Ÿåˆ©ç”¨å‡½æ•°çš„è°ƒç”¨æ ˆæ¥ç®¡ç†çŠ¶æ€ï¼Œè€Œä¸éœ€è¦é¢å¤–çš„å˜é‡æˆ–æ§åˆ¶ç»“æ„ã€‚
3. æŠ½è±¡æ€ç»´ï¼šé€’å½’é¼“åŠ±æ›´æŠ½è±¡çš„æ€è€ƒæ–¹å¼ï¼Œå¯ä»¥å°†é—®é¢˜åˆ†è§£æˆæ›´å°çš„å­é—®é¢˜ï¼Œä½¿å¾—é—®é¢˜çš„è§£å†³æ›´åŠ æ¸…æ™°å’Œæ¨¡å—åŒ–ã€‚

é‚£ä¹ˆï¼Œä»£ä»·æ˜¯ä»€ä¹ˆï¼Ÿ

æ­£å¦‚ç¬¬äºŒç‚¹æ‰€æåˆ°çš„ï¼Œå¦‚æœæˆ‘ä»¬å°†é€’å½’åˆ†ä¸ºã€Œå±•å¼€å‡†å¤‡ã€å’Œã€Œè¿”å›åº”ç”¨ã€ä¸¤ä¸ªé˜¶æ®µï¼Œåœ¨å±•å¼€è¿‡ç¨‹ä¸­ï¼Œæ¯æ¬¡å¯¹è‡ªèº«çš„è°ƒç”¨éƒ½ä¼šåœ¨è°ƒç”¨æ ˆä¸­åˆ›å»ºæ–°çš„å¸§ï¼Œå¦‚æœé€’å½’è¿‡æ·±ï¼Œå°†å¯¼è‡´æ ˆåŒºè¢«å æ»¡ï¼Œæœ€ç»ˆå‡ºç° Stack Overflowï¼ˆæ ˆæº¢å‡ºï¼‰é”™è¯¯ã€‚æ­¤å¤–ï¼Œå‡½æ•°è°ƒç”¨æœ¬èº«ä¹Ÿå…·æœ‰ä¸€å®šå¼€é”€ã€‚

æ€æ ·æ‰èƒ½æ—¢ä½¿ç”¨é€’å½’ï¼Œåˆä¿è¯æ€§èƒ½å‘¢ï¼Ÿ

æˆ–è®¸ä½ å·²ç»æ³¨æ„åˆ°ï¼ŒKotlin å®ç°çš„ `reduce` å‡½æ•°æ¯”åˆ«äººå¤šäº† `tailrec`ï¼Œè¿™ä¸ªå…³é”®å­—æ„å‘³ç€ä»€ä¹ˆï¼Ÿæˆ‘ä»¬ä½¿ç”¨åç¼–è¯‘å·¥å…·å°†å­—èŠ‚ç åç¼–è¯‘ä¸º Java ä»£ç ï¼Œæ­¤æ—¶ä¼šå‘ç°ï¼Œé€’å½’ç«Ÿå˜æˆäº†å¾ªç¯ï¼

```java
public static final Object reduce(@NotNull List $this$reduce, Object init, @NotNull Function2 f) {
    Intrinsics.checkNotNullParameter($this$reduce, "<this>");
    Intrinsics.checkNotNullParameter(f, "f");

    while(!$this$reduce.isEmpty()) {
        Object x = CollectionsKt.first($this$reduce);
        List xs = CollectionsKt.drop((Iterable)$this$reduce, 1);
        Object var5 = f.invoke(init, x);
        $this$reduce = xs;
        init = var5;
        f = f;
    }

    return init;
}
```

ä¸ºæ–¹ä¾¿ç†è§£ï¼Œæˆ‘ä»¬å°†å…¶æ•´ç†ä¸º Kotlin ä»£ç ï¼š

```kotlin
fun <T, U> List<T>.reduce(init: U, f: (U, T) -> U): U {
    var list = this
    var init = init
    while (list.isNotEmpty()) {
        val x = list.first()
        val xs = list.drop(1)
        init = f(init, x)
        list = xs
    }
    return init
}
```

è¿™å°±æ˜¯æ‰€è°“çš„å°¾é€’å½’ä¼˜åŒ–ã€‚

å®é™…ä¸Šï¼Œå°¾é€’å½’ä¼˜åŒ–æ˜¯é€’å½’ä¸å°¾è°ƒç”¨ä¼˜åŒ–ï¼ˆTail Call Optimizationï¼Œç®€ç§° TCOï¼‰ç›¸ç»“åˆçš„ç‰¹æ®Šäº§ç‰©ã€‚æ‰€è°“ã€Œå°¾è°ƒç”¨ã€æŒ‡ä¸€ä¸ªå‡½æ•°é‡Œçš„æœ€åä¸€ä¸ªåŠ¨ä½œæ˜¯è¿”å›ä¸€ä¸ªå‡½æ•°çš„è°ƒç”¨ç»“æœ[^2]ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```typescript
function f() {
  const n = nuclearBomb()
  return g(n)
}

function g(n: number) {
  return n + 1
}
```

è¿™é‡Œçš„å‡½æ•° `f` ä¸­çš„ `g(n)` å°±æ˜¯å°¾è°ƒç”¨ï¼Œé‚£ä¹ˆï¼Œã€Œä¼˜åŒ–ã€åˆæ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ

æ­£å¸¸æ¥è¯´ï¼Œè°ƒç”¨æ–°çš„å‡½æ•°éœ€è¦åˆ›æ–°æ–°çš„æ ˆå¸§å¹¶å°†å…¶æ¨å…¥åˆ°è°ƒç”¨æ ˆä¸­ï¼Œä½†ç”±äºå°¾è°ƒç”¨å·²å¤„äºå‡½æ•°çš„æœ€åï¼Œå½“å‰å¸§ä¸­ä¿¡æ¯ä¸ä¼šè¢«ä½¿ç”¨ï¼Œæ‰€ä»¥è¢«è°ƒç”¨å‡½æ•°å¯ä»¥ç›´æ¥é‡ç”¨å½“å‰å¸§è€Œæ— éœ€åˆ›å»ºæ–°å¸§ã€‚

è¿™æ˜¯ä¸€èˆ¬æƒ…å†µä¸‹çš„ TCOï¼Œä¸éš¾ç†è§£ã€‚ä½†æ˜¯ï¼Œå½“å°¾è°ƒç”¨å˜ä¸ºå¯¹è‡ªèº«çš„é€’å½’è°ƒç”¨è€Œä½ç½®ä¸å˜ï¼ˆå³å°¾é€’å½’ï¼‰æ—¶ï¼Œä¼˜åŒ–å°±å˜å¾—æœ‰è¶£èµ·æ¥ã€‚

å¯¹äºå°¾é€’å½’ä¼˜åŒ–çš„æ•ˆæœï¼Œæƒ³å¿…çœ‹äº†ä¸Šé¢ `reduce` çš„ä¾‹å­åä¸éš¾ç†è§£ï¼Œé‚£ä¹ˆä¸ºä»€ä¹ˆå°¾é€’å½’èƒ½å¤Ÿè¢«ä¼˜åŒ–å‘¢ï¼Ÿåœ¨è®¨è®ºè¿™ä¸ªé—®é¢˜ä¹‹å‰ï¼Œæˆ‘ä»¬é¦–å…ˆæ¥çœ‹å¦å¤–ä¸€ä¸ªå‡½æ•°â¸º`isEven` å¶æ•°åˆ¤æ–­ï¼š

```typescript
const isEven = (n: number) => {
  if (n === 0) {
    return true
  }
  return !isEven(n - 1)
}
```

è¿™ä¸ªåˆ¤æ–­å¥‡å¶çš„æ€è·¯éå¸¸æœ‰è¶£ã€‚ç”±äºè¯¥å‡½æ•°çš„æœ€åä¸€ä¸ªæ“ä½œæ˜¯é€»è¾‘å–å `!`ï¼Œæ‰€ä»¥ä¸æ„æˆå°¾é€’å½’ã€‚å¦‚æœæƒ³è¦å°¾é€’å½’ï¼Œæˆ‘ä»¬å¿…é¡»ä½¿ `isEven` å‡½æ•°è°ƒç”¨ä½œä¸ºæœ€åä¸€ä¸ªæ“ä½œï¼Œäºæ˜¯ä¾¿æœ‰äº†ä»¥ä¸‹å®ç°ï¼š

```typescript
const isEven = (n: number, even = true) => {
  if (n === 0) {
    return even
  }
  return isEven(n - 1, !even)
}
```

å½“çœ‹åˆ°å°¾é€’å½’å®ç°æ—¶ï¼Œä½ ä¼šå‘ç°åŸé€’å½’å®ç°æ‰€å…·æœ‰çš„é‚£ç§ç®€æ´ä¼˜é›…ä¼¼ä¹å·²ä¸å¤å­˜åœ¨ã€‚æˆ‘ä»¬çŸ¥é“ï¼Œé€’å½’ä¹‹æ‰€ä»¥ç®€æ´æ˜¯å› ä¸ºå®ƒèƒ½è‡ªåŠ¨ä¿å­˜è¿ç®—çŠ¶æ€ï¼Œè€Œå¾ªç¯åˆ™éœ€è¦æˆ‘ä»¬è‡ªå·±ä½¿ç”¨å˜é‡å­˜å‚¨çŠ¶æ€ã€‚æ˜¾ç„¶ï¼Œå°¾é€’å½’ä¹Ÿè¦éµå¾ªè®¡ç®—æœºç§‘å­¦ï¼Œæ—¢ä¸æƒ³æ‰‹åŠ¨å¤„ç†çŠ¶æ€åˆä¸æƒ³å½±å“æ€§èƒ½æ˜¯ä¸å¯èƒ½çš„ã€‚äºæ˜¯ï¼Œæˆ‘ä»¬åªå¥½æŠŠå˜é‡æ”¾åˆ°äº†å‡½æ•°å‚æ•°çš„ä½ç½®ä¸Šï¼Œè¿™å°±æ˜¯å°¾é€’å½’çš„çœŸç›¸ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå€ŸåŠ©å¾ªç¯å®ç°çš„æ€è·¯å°±èƒ½æŠŠ body recursion æ”¹å†™ä¸º tail recursionã€‚

æ¥ä¸‹æ¥ï¼Œæ‰§è¡Œä»¥ä¸‹æ­¥éª¤å°±å¯ä»¥å°†å°¾é€’å½’ä¼˜åŒ–ä¸ºå¾ªç¯ï¼š

1. å‡½æ•°ç­¾åä¸å˜ã€‚
2. å°†é€’å½’ base case çš„å–åä½œä¸ºå¾ªç¯æ¡ä»¶ã€‚
3. å°† base case å¤–çš„æ¯ä¸€æ­¥éƒ½åŸå°ä¸åŠ¨åœ°å¤åˆ¶è¿‡æ¥ã€‚
4. å¯¹äºä¼ å…¥é€’å½’å‡½æ•°çš„æ¯ä¸ªå®å‚ï¼Œå®šä¹‰æ–°çš„å˜é‡å­˜å‚¨è®¡ç®—åçš„å€¼ã€‚
5. æ›´æ–°å‡½æ•°å‚æ•°ã€‚
6. åœ¨å¾ªç¯å¤–è¿”å› base case ä¸­çš„è¿”å›å€¼ã€‚

å¯¹äº `isEven` çš„ä¼˜åŒ–ç»“æœå¦‚ä¸‹ï¼š

```typescript
const isEven = (n: number, even = true) => {
  while (!(n === 0)) {
    const p0 = n - 1
    const p1 = !even
    n = p0
    even = p1
  }
  return even
}
```

çœ‹ä¸Šå»ï¼Œå°¾é€’å½’ä¼˜åŒ–ä¼¼ä¹ä¸ TCO æœ‰ä¸€å®šåŒºåˆ«ï¼Œå®é™…ä¸Šï¼Œä»åº•å±‚æ¥çœ‹ï¼Œä»–ä»¬éƒ½æŠŠè°ƒç”¨æŒ‡ä»¤æ”¹å†™ä¸ºè·³è½¬æŒ‡ä»¤ï¼Œå°¤å…¶æ˜¯ä¸Šè¿°å°¾é€’å½’ä¼˜åŒ–ä¸­çš„ç¬¬äº”æ­¥ï¼Œå¯ä»¥å¾ˆæ˜æ˜¾åœ°çœ‹å‡ºè¿™æ­£æ˜¯åœ¨é€šè¿‡è¦†ç›–å‡½æ•°åŸæœ‰å‚æ•°ä»¥å®ç°å¸§å¤ç”¨ã€‚

å›åˆ°æœ€åˆï¼Œç”±äº `reduce` çš„ä½œç”¨ä¸å¾ªç¯ç±»ä¼¼ï¼Œæ‰€ä»¥å…¶å®ç°å¤©ç„¶ç¬¦åˆå°¾é€’å½’å½¢å¼ã€‚åœ¨ Kotlin ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡æ·»åŠ  `tailrec` ä½¿ Kotlin ç¼–è¯‘å™¨åº”ç”¨å°¾é€’å½’ä¼˜åŒ–ï¼Œæ­¤æ—¶ï¼Œå°¾é€’å½’å°†å˜ä¸ºã€Œä¼ªé€’å½’ã€ï¼Œé€’å½’å˜ä¸ºå¾ªç¯ï¼Œ`call` å˜ä¸º `jmp`ï¼Œé€’å½’è‡ªç„¶æ˜¯å‡çš„äº†ã€‚

é‚£ä¹ˆï¼Œæˆ‘ä»¬æ˜¯å¦åº”è¯¥å°†ä¸€åˆ‡é€’å½’å‡½æ•°æ”¹ä¸ºå°¾é€’å½’å½¢å¼å‘¢ï¼Ÿé¦–å…ˆï¼Œæˆ‘è®¤ä¸ºå°¾é€’å½’æ˜¯ä¸€ç§è¿«ä¸å¾—å·²çš„æ–¹æ¡ˆï¼šå³è¦æ€§èƒ½ï¼Œåˆå¿…é¡»éµå¾ªä¸å¯å˜è§„åˆ™ï¼Œäºæ˜¯åªèƒ½ç‰ºç‰²é€’å½’åŸæœ¬çš„ç®€ä¾¿ï¼Œæœ€åå†å€ŸåŠ©ç¼–è¯‘å™¨ä¼˜åŒ–å®Œæˆæ”¹å†™ï¼›å…¶æ¬¡ï¼Œ[å°¾é€’å½’ä¼˜åŒ–åæ€§èƒ½å¹¶ä¸ä¸€å®šæ›´å¼º](https://pragtob.wordpress.com/2016/06/16/tail-call-optimization-in-elixir-erlang-not-as-efficient-and-important-as-you-probably-think/)ï¼Œä¸è€ƒè™‘å®é™…æƒ…å†µçš„ä¼˜åŒ–å±äºè¿‡åº¦ä¼˜åŒ–è¡Œä¸ºï¼›æœ€åï¼ŒTCO ä¼šç ´åè°ƒç”¨æ ˆä¿¡æ¯ï¼Œè¿™ä¹Ÿè®¸ä¼šå½±å“è°ƒè¯•ã€‚

ç»¼ä¸Šï¼Œçˆ±ç”¨å•¥ç”¨å•¥ï¼Œä»£ç æ˜¯ç»™äººçœ‹çš„ï¼Œå†™å¾—èˆ’æœæœ€é‡è¦ã€‚

## æ€»ç»“

å…¶å®å†™è¿™ç¯‡æ–‡ç« çš„åˆå¿ƒçœŸçš„åªæ˜¯æƒ³åç³Ÿä¸€ä¸‹ JS ä¸­çš„æ­£åˆ™è¡¨è¾¾å¼ï¼Œå†ç®€å•è®²è®²å‡½æ•°ä¸é€’å½’ï¼Œä½†ä¸çŸ¥ä¸è§‰é—´å°±æŠŠä»¥å‰åŸºæœ¬ä¸ä¼šçš„ä¸‰é—¨å‡½æ•°å¼è¯­è¨€åŠ ä¸Šäº†ï¼Œè‡³å°‘ï¼Œç°åœ¨ä¸ä¼šå¯¹ä»–ä»¬æ„Ÿåˆ°é™Œç”Ÿäº†ã€‚å†ä¹‹ååˆåŸºæœ¬æ˜ç™½äº† TCO çš„åŸç†ï¼Œä¹Ÿæ„ˆå‘è®¤è¯†åˆ°æ±‡ç¼–çŸ¥è¯†çš„ä¸å¯æˆ–ç¼ºã€‚

çœŸæ˜¯æœ‰è¶£å•Šã€‚

[^1]: [Fixing JavaScript Date â€“ Getting Started â€“ Maggie's Blog](https://maggiepint.com/2017/04/09/fixing-javascript-date-getting-started/)
[^2]: [å°¾è°ƒç”¨ - ç»´åŸºç™¾ç§‘ï¼Œè‡ªç”±çš„ç™¾ç§‘å…¨ä¹¦](https://zh.wikipedia.org/wiki/å°¾è°ƒç”¨)
